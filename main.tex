%%%%%%%%%%%%%%%%%%%%%%% file template.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is a general template file for the LaTeX package SVJour3
% for Springer journals.          Springer Heidelberg 2010/09/16
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\RequirePackage{fix-cm}
%

\documentclass{svjour3}                     % onecolumn (standard format)
%\documentclass[smallcondensed]{svjour3}     % onecolumn (ditto)
%\documentclass[smallextended]{svjour3}       % onecolumn (second format)
%\documentclass[twocolumn]{svjour3}          % twocolumn
%

\usepackage{xspace}
\usepackage[sort&compress]{natbib}

\newcommand{\eg}{\textit{e.g.,}\xspace}
% Insert the name of "your journal" with
 \journalname{Empirical Software Engineering}
%
\begin{document}
%An Empirical Study on the Developers' Perception of Linguistic Antipatterns
\title{Guest Editorial: Special Section on Software Reverse Engineering}
%\subtitle{Do you have a subtitle?\\ If so, write it here}
%\titlerunning{Short form of title}        % if too long for running head

\author{Romain Robbes \and  Rocco Oliveto \and Massimiliano Di Penta}
%\authorrunning{Short form of author list} % if too long for running head
\institute{         	
         		Romain Robbes\at
				Department of Computer Science (DCC), University of Chile, Chile\\
				\email{rrobbes@dcc.uchile.cl}\\
\and
	Rocco Oliveto\at
				Department of Bioscience and Territory, University of Molise, Pesche (IS) Italy\\
				\email{rocco.oliveto@unimol.it}\\
\and
Massimiliano Di Penta \at
          		Department of Engineering, University of Sannio, Benevento, Italy  \\
          	 	\email{dipenta@unisannio.it}
}
\date{Received: date / Accepted: date}
% The correct dates will be entered by the editor


\maketitle

As defined in a seminal taxonomy by Chikofsky and Cross \citep{DBLP:journals/software/ChikofskyC90} software reverse engineering is:

\begin{quote}
 {\em ``the process of analyzing a subject system to (i) identify the systemâ€™s components and their inter-relationships and (ii) create representations of the system in another form or at a higher level of abstraction.''}
\end{quote}

Such an analysis process pertains artifacts that can be at an extremely low-level, \eg binary files or system execution traces, or at intermediate-level, \eg such as source code, patches, and defects, and the history and discussions associated to these artifacts. 

Software reverse engineering is a mature research field with high practical relevance: often, the only way to get an understanding of a large and complex software system is through these lower-level artifacts, especially when higher-level artifacts are absent or outdated. In general, almost every time one has to evolve an existing software system---and especially when source code or binary is the only reliable source of documentation---reverse engineering becomes a key element software evolution \citep{DBLP:conf/icse/CanforaP07}. Indeed, in such cases reverse engineering is highly recommended by the IEEE Std. 1219 \citep{IEEE1999-Std1219} for software maintenance. 

This special issue features six papers on the topic of reverse engineering, using an array of techniques and data sources: some use very low-level artifacts, while some use higher-level ones and historical information.

The first articles from this special issue, \emph{``On the detection of custom memory allocators in C binaries''} \citep{memory}, focuses on binary analysis. The article describes a technique to detect custom memory allocators and deallocators, which is vital to properly detect and track data structures in performance-critical applications. The tool implementing the technique, MemBrush, has been evaluated on a large number of real-world applications, and was found to have a high accuracy. MemBrush can then transfer that data to existing reverse engineering tools. 

The article \emph{``Scalable data structure detection and classification for C/C++ binaries''} \citep{structures} also deals with binary analysis. The tool presented in the article, {\em MemPick}, analyzes the links between the objects in memory in order to detect higher-level data structures. {\em MemPick} can detect several commonly used data structures, including several types of linked lists, trees, or graphs. The tool was evaluated on 30 different systems.

In \emph{``Inferring extended finite state machine models from software executions''} \citep{stateMachines}, the focus shifts to execution traces. More specifically, the goal of the article is to infer Extented Finite State Machines (EFSMs) from the excution traces. EFSMs can blend the control and data aspects of the software system under study. The technique presented to infer EFSM is based on machine learning, and is evaluated quantitatively and qualitatively on three software systems.

The remainder of the special issue, starting with \emph{``Mining architectural violations from version history''} \citep{architecture}, exploits higher-level information. The article combines static and historical analysis in the context of checking the architectural conformance of a software system. Since detecting architectural violations in this way is a challenging problem, the article also proposes an iterative process for experts to verify the conformance semi-automatically,

In the article \emph{``Evaluating the impact of design pattern and anti-pattern dependencies on changes and faults''} \citep{patterns}, the focus is on classes depending on design pattern (and anti-pattern) elements, under the assumption that the good and/or bad characteritics of patterns and anti-patterns may propagate to their dependencies. The article puts that assumption to the test by analysing the fault-proneness and change-proneness of depencies of six design patterns and ten anti-patterns, in the sequence of releases of three software systems.

Finally, this special issue concludes with \emph{``Investigating technical and non-technical factors influencing modern code review''} \citep{codeReview}, in which the code review process of two large open-source projects is studied, in order to better understand the factors that might result in whether the code submissions are evaluated in a timely manner or not. Reverse engineering techniques are applied in order to reconstruct the patch submission process from the information in the issue tracking and code review systems.

These six articles exemplify the breath, depth and quality of the research performed in the field of software reverse engineering.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%







\bibliographystyle{spbasic}

\bibliography{main}   % name your BibTeX data base

\end{document}
% end of file template.tex

